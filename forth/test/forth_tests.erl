%% Generated with 'testgen v0.2.0'
%% Revision 1 of the exercises generator was used
%% https://github.com/exercism/problem-specifications/raw/b230e1eb1d51be8228645e5c76f96b0e6dd1d2bd/exercises/forth/canonical-data.json
%% This file is automatically generated from the exercises canonical data.

-module(forth_tests).

-include_lib("erl_exercism/include/exercism.hrl").
-include_lib("eunit/include/eunit.hrl").




'1_numbers_just_get_pushed_onto_the_stack_test_'() ->
    {"numbers just get pushed onto the stack",
     ?_assertEqual([1, 2, 3, 4, 5],
		   forth:evaluate(["1 2 3 4 5"]))}.

'2_pushes_negative_numbers_onto_the_stack_test_'() ->
    {"pushes negative numbers onto the stack",
     ?_assertEqual([-1, -2, -3, -4, -5],
		   forth:evaluate(["-1 -2 -3 -4 -5"]))}.

'3_can_add_two_numbers_test_'() ->
    {"can add two numbers",
     ?_assertEqual([3], forth:evaluate(["1 2 +"]))}.

'4_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["+"]))}.

'5_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 +"]))}.

'6_can_subtract_two_numbers_test_'() ->
    {"can subtract two numbers",
     ?_assertEqual([-1], forth:evaluate(["3 4 -"]))}.

'7_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["-"]))}.

'8_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 -"]))}.

'9_can_multiply_two_numbers_test_'() ->
    {"can multiply two numbers",
     ?_assertEqual("\b", forth:evaluate(["2 4 *"]))}.

'10_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["*"]))}.

'11_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 *"]))}.

'12_can_divide_two_numbers_test_'() ->
    {"can divide two numbers",
     ?_assertEqual([4], forth:evaluate(["12 3 /"]))}.

'13_performs_integer_division_test_'() ->
    {"performs integer division",
     ?_assertEqual([2], forth:evaluate(["8 3 /"]))}.

'14_errors_if_dividing_by_zero_test_'() ->
    {"errors if dividing by zero",
     ?_assertError(_, forth:evaluate(["4 0 /"]))}.

'15_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["/"]))}.

'16_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 /"]))}.

'17_addition_and_subtraction_test_'() ->
    {"addition and subtraction",
     ?_assertEqual([-1], forth:evaluate(["1 2 + 4 -"]))}.

'18_multiplication_and_division_test_'() ->
    {"multiplication and division",
     ?_assertEqual([2], forth:evaluate(["2 4 * 3 /"]))}.

'19_copies_a_value_on_the_stack_test_'() ->
    {"copies a value on the stack",
     ?_assertEqual([1, 1], forth:evaluate(["1 dup"]))}.

'20_copies_the_top_value_on_the_stack_test_'() ->
    {"copies the top value on the stack",
     ?_assertEqual([1, 2, 2], forth:evaluate(["1 2 dup"]))}.

'21_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["dup"]))}.

'22_removes_the_top_value_on_the_stack_if_it_is_the_only_one_test_'() ->
    {"removes the top value on the stack if "
     "it is the only one",
     ?_assertEqual([], forth:evaluate(["1 drop"]))}.

'23_removes_the_top_value_on_the_stack_if_it_is_not_the_only_one_test_'() ->
    {"removes the top value on the stack if "
     "it is not the only one",
     ?_assertEqual([1], forth:evaluate(["1 2 drop"]))}.

'24_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["drop"]))}.

'25_swaps_the_top_two_values_on_the_stack_if_they_are_the_only_ones_test_'() ->
    {"swaps the top two values on the stack "
     "if they are the only ones",
     ?_assertEqual([2, 1], forth:evaluate(["1 2 swap"]))}.

'26_swaps_the_top_two_values_on_the_stack_if_they_are_not_the_only_ones_test_'() ->
    {"swaps the top two values on the stack "
     "if they are not the only ones",
     ?_assertEqual([1, 3, 2],
		   forth:evaluate(["1 2 3 swap"]))}.

'27_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["swap"]))}.

'28_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 swap"]))}.

'29_copies_the_second_element_if_there_are_only_two_test_'() ->
    {"copies the second element if there are "
     "only two",
     ?_assertEqual([1, 2, 1], forth:evaluate(["1 2 over"]))}.

'30_copies_the_second_element_if_there_are_more_than_two_test_'() ->
    {"copies the second element if there are "
     "more than two",
     ?_assertEqual([1, 2, 3, 2],
		   forth:evaluate(["1 2 3 over"]))}.

'31_errors_if_there_is_nothing_on_the_stack_test_'() ->
    {"errors if there is nothing on the stack",
     ?_assertError(_, forth:evaluate(["over"]))}.

'32_errors_if_there_is_only_one_value_on_the_stack_test_'() ->
    {"errors if there is only one value on "
     "the stack",
     ?_assertError(_, forth:evaluate(["1 over"]))}.

'33_can_consist_of_built_in_words_test_'() ->
    {"can consist of built-in words",
     ?_assertEqual([1, 1, 1],
		   forth:evaluate([": dup-twice dup dup ;",
				   "1 dup-twice"]))}.

'34_execute_in_the_right_order_test_'() ->
    {"execute in the right order",
     ?_assertEqual([1, 2, 3],
		   forth:evaluate([": countup 1 2 3 ;", "countup"]))}.

'35_can_override_other_user_defined_words_test_'() ->
    {"can override other user-defined words",
     ?_assertEqual([1, 1, 1],
		   forth:evaluate([": foo dup ;", ": foo dup dup ;",
				   "1 foo"]))}.

'36_can_override_built_in_words_test_'() ->
    {"can override built-in words",
     ?_assertEqual([1, 1],
		   forth:evaluate([": swap dup ;", "1 swap"]))}.

'37_can_override_built_in_operators_test_'() ->
    {"can override built-in operators",
     ?_assertEqual("\f",
		   forth:evaluate([": + * ;", "3 4 +"]))}.

'38_can_use_different_words_with_the_same_name_test_'() ->
    {"can use different words with the same "
     "name",
     ?_assertEqual([5, 6],
		   forth:evaluate([": foo 5 ;", ": bar foo ;", ": foo 6 ;",
				   "bar foo"]))}.

'39_can_define_word_that_uses_word_with_the_same_name_test_'() ->
    {"can define word that uses word with "
     "the same name",
     ?_assertEqual("\v",
		   forth:evaluate([": foo 10 ;", ": foo foo 1 + ;",
				   "foo"]))}.

'40_cannot_redefine_non_negative_numbers_test_'() ->
    {"cannot redefine non-negative numbers",
     ?_assertError(_, forth:evaluate([": 1 2 ;"]))}.

'41_cannot_redefine_negative_numbers_test_'() ->
    {"cannot redefine negative numbers",
     ?_assertError(_, forth:evaluate([": -1 2 ;"]))}.

'42_errors_if_executing_a_non_existent_word_test_'() ->
    {"errors if executing a non-existent word",
     ?_assertError(_, forth:evaluate(["foo"]))}.

'43_only_defines_locally_test_'() ->
    [{"only defines locally (first)",
      ?_assertEqual([0],
		    forth:evaluate([": + - ;", "1 1 +"]))},
     {"only defines locally (second)",
      ?_assertEqual([2], forth:evaluate(["1 1 +"]))}].

'44_dup_is_case_insensitive_test_'() ->
    {"DUP is case-insensitive",
     ?_assertEqual([1, 1, 1, 1],
		   forth:evaluate(["1 DUP Dup dup"]))}.

'45_drop_is_case_insensitive_test_'() ->
    {"DROP is case-insensitive",
     ?_assertEqual([1],
		   forth:evaluate(["1 2 3 4 DROP Drop drop"]))}.

'46_swap_is_case_insensitive_test_'() ->
    {"SWAP is case-insensitive",
     ?_assertEqual([2, 3, 4, 1],
		   forth:evaluate(["1 2 SWAP 3 Swap 4 swap"]))}.

'47_over_is_case_insensitive_test_'() ->
    {"OVER is case-insensitive",
     ?_assertEqual([1, 2, 1, 2, 1],
		   forth:evaluate(["1 2 OVER Over over"]))}.

'48_user_defined_words_are_case_insensitive_test_'() ->
    {"user-defined words are case-insensitive",
     ?_assertEqual([1, 1, 1, 1],
		   forth:evaluate([": foo dup ;", "1 FOO Foo foo"]))}.

'49_definitions_are_case_insensitive_test_'() ->
    {"definitions are case-insensitive",
     ?_assertEqual([1, 1, 1, 1],
		   forth:evaluate([": SWAP DUP Dup dup ;", "1 swap"]))}.
